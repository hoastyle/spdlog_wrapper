#pragma once

#include <iostream>
#include <memory>
#include <string>
#include <unordered_map>

#include "spdlog/spdlog.h"
#include "spdlog/sinks/rotating_file_sink.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/formatter.h"

namespace mm_log {

// 定义日志级别
enum class LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
};

class Logger {
public:
    static Logger& Instance() {
        static Logger instance;
        return instance;
    }

    // 初始化日志系统
    bool Initialize(const std::string& log_file_prefix, 
                    size_t max_file_size = 10 * 1024 * 1024,  // 默认10MB
                    size_t max_files = 5,                     // 默认5个文件轮转
                    bool enable_debug = true,
                    bool enable_console = true,               // 默认启用控制台输出
                    bool enable_file = true) {                // 默认启用文件输出
        try {
            // 保存设置
            enable_debug_ = enable_debug;
            enable_console_ = enable_console;
            enable_file_ = enable_file;
            
            if (!enable_console_ && !enable_file_) {
                std::cerr << "Warning: Both console and file logging are disabled!" << std::endl;
                return false;
            }
            
            // 创建多重日志记录器，将合并不同的输出目标
            std::vector<spdlog::sink_ptr> sinks;
            
            // 添加控制台输出
            if (enable_console_) {
                auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
                console_sink->set_pattern("%P:I%Y%m%d %H:%M:%S.%f %t :0] %v");
                sinks.push_back(console_sink);
            }
            
            // 添加文件输出
            if (enable_file_) {
                // 创建INFO文件sink（包含所有级别）
                auto info_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
                    log_file_prefix + ".INFO", max_file_size, max_files);
                info_sink->set_pattern("%P:I%Y%m%d %H:%M:%S.%f %t :0] %v");
                info_sink->set_level(spdlog::level::debug);
                sinks.push_back(info_sink);
                
                // 创建WARN文件sink（只包含WARN和ERROR级别）
                auto warn_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
                    log_file_prefix + ".WARN", max_file_size, max_files);
                warn_sink->set_pattern("%P:I%Y%m%d %H:%M:%S.%f %t :0] %v");
                warn_sink->set_level(spdlog::level::warn);
                sinks.push_back(warn_sink);
                
                // 创建ERROR文件sink（只包含ERROR级别）
                auto error_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
                    log_file_prefix + ".ERROR", max_file_size, max_files);
                error_sink->set_pattern("%P:I%Y%m%d %H:%M:%S.%f %t :0] %v");
                error_sink->set_level(spdlog::level::err);
                sinks.push_back(error_sink);
            }
            
            // 创建并注册主日志记录器，包含所有sink
            auto logger = std::make_shared<spdlog::logger>("main_logger", sinks.begin(), sinks.end());
            logger->set_level(enable_debug_ ? spdlog::level::debug : spdlog::level::info);
            spdlog::register_logger(logger);
            spdlog::set_default_logger(logger);
            
            initialized_ = true;
            return true;
        } catch (const spdlog::spdlog_ex& ex) {
            std::cerr << "Log initialization failed: " << ex.what() << std::endl;
            return false;
        }
    }

    // 获取源文件的基本名称（去掉路径）
    static std::string GetBaseName(const std::string& file_path) {
        size_t pos = file_path.find_last_of("/\\");
        if (pos != std::string::npos) {
            return file_path.substr(pos + 1);
        }
        return file_path;
    }

    // 日志记录函数
    template<typename... Args>
    void Log(LogLevel level, const char* file, const char* func, int line, const char* fmt, Args&&... args) {
        if (!initialized_) {
            return;
        }

        // 如果是DEBUG级别但DEBUG被禁用，则返回
        if (level == LogLevel::DEBUG && !enable_debug_) {
            return;
        }

        // 构建日志前缀（类名::函数名() 行号 级别标识）
        std::string basename = GetBaseName(file);
        std::string classname = basename.substr(0, basename.find_last_of('.'));
        std::string prefix = fmt::format("{}::{}() {} {}: ", 
                          classname,         // 类名（提取自文件名）
                          func,              // 函数名
                          line,              // 行号
                          GetLevelChar(level)); // 级别标识（D/I/W/E）

        // 根据日志级别选择对应的日志记录器与方法
        auto logger = spdlog::get("main_logger");
        if (!logger) {
            return;
        }

        switch (level) {
            case LogLevel::DEBUG:
                logger->debug(prefix + fmt, std::forward<Args>(args)...);
                break;
            case LogLevel::INFO:
                logger->info(prefix + fmt, std::forward<Args>(args)...);
                break;
            case LogLevel::WARN:
                logger->warn(prefix + fmt, std::forward<Args>(args)...);
                break;
            case LogLevel::ERROR:
                logger->error(prefix + fmt, std::forward<Args>(args)...);
                break;
        }
    }

private:
    // 私有构造函数（单例模式）
    Logger() : initialized_(false), enable_debug_(true), enable_console_(true), enable_file_(true) {}
    
    ~Logger() {
        // 刷新所有日志
        if (initialized_) {
            spdlog::shutdown();
        }
    }

    // 获取日志级别对应的字符
    static char GetLevelChar(LogLevel level) {
        switch (level) {
            case LogLevel::DEBUG: return 'D';
            case LogLevel::INFO:  return 'I';
            case LogLevel::WARN:  return 'W';
            case LogLevel::ERROR: return 'E';
            default:              return '?';
        }
    }

    // 成员变量
    bool initialized_;
    bool enable_debug_;
    bool enable_console_;
    bool enable_file_;
};

} // namespace mm_log

// 宏定义，用于简化日志调用
#define MM_DEBUG(fmt, ...) \
    mm_log::Logger::Instance().Log(mm_log::LogLevel::DEBUG, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)

#define MM_INFO(fmt, ...) \
    mm_log::Logger::Instance().Log(mm_log::LogLevel::INFO, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)

#define MM_WARN(fmt, ...) \
    mm_log::Logger::Instance().Log(mm_log::LogLevel::WARN, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)

#define MM_ERROR(fmt, ...) \
    mm_log::Logger::Instance().Log(mm_log::LogLevel::ERROR, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)
